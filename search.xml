<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker常用命令</title>
    <url>/2022/05/29/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h2><p>docker是一个开源的容器引擎，可以将开发者的应用以及依赖包打包到轻量级、可移植的容器中，从而部署到Linux系统中，可以实现虚拟化操作。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低</p>
<h2 id="docker的优缺点"><a href="#docker的优缺点" class="headerlink" title="docker的优缺点"></a>docker的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.更快的进行项目交付与部署</span><br><span class="line">2.易于迁移与扩展</span><br><span class="line">3.CPU/内存资源的开销少</span><br><span class="line">4.环境隔离</span><br><span class="line">不同的容器之间环境互不依赖，因此可以部署在同一台机器上</span><br></pre></td></tr></table></figure>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.无法在32bit的linux/Windows/unix环境下使用。</span><br><span class="line">2.对于磁盘的管理比较有限</span><br></pre></td></tr></table></figure>
<h2 id="docker使用场景"><a href="#docker使用场景" class="headerlink" title="docker使用场景"></a>docker使用场景</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.web应用的打包与部署，例如flask环境、redis、mongdb等环境</span><br><span class="line">2.自动化测试与持续集成、发布</span><br><span class="line">3.任何不依赖于硬件（或可以将依赖虚拟化）的可独立的环境打包，例如安卓不同项目、不同版本的编译</span><br></pre></td></tr></table></figure>
<h2 id="容器生命周期管理命令"><a href="#容器生命周期管理命令" class="headerlink" title="容器生命周期管理命令"></a>容器生命周期管理命令</h2><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>创建一个新容器：可选参数：</p>
<ul>
<li>–name：设置容器的名称</li>
<li>-d: 容器以后台模式运行</li>
<li>-i: 交互式方式操作</li>
<li>-t: 分配一个伪终端</li>
<li>-p: 设置将容器的端口映射到主机的端口</li>
<li>-v: 设置将主机的路径映射到容器的对应路径，当映射完成后，主机路径内容改变会影响到容器对于路径的内容改变</li>
<li>&#x2F;bin&#x2F;bash: 在创建玩容器后直接进入docker的命令行终端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。  </span></span><br><span class="line">docker run --name mynginx -d nginx:latest  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。  </span></span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。  </span></span><br><span class="line">docker run -it nginx:latest /bin/bash  </span><br></pre></td></tr></table></figure>
<h3 id="start-x2F-stop-x2F-restart"><a href="#start-x2F-stop-x2F-restart" class="headerlink" title="start&#x2F;stop&#x2F;restart"></a>start&#x2F;stop&#x2F;restart</h3><ul>
<li>docker start : 启动一个或多个已经被停止的容器。</li>
<li>docker stop : 停止一个运行中的容器。</li>
<li>docker restart : 重启容器。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动已被停止的容器mynginx  </span></span><br><span class="line">docker start mynginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止运行中的容器mynginx  </span></span><br><span class="line">docker stop mynginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启容器mynginx  </span></span><br><span class="line">docker restart mynginx </span><br></pre></td></tr></table></figure>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3>杀掉一个运行中的容器。可选参数：</li>
<li>-s : 发送什么信号到容器，默认 KILL<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据容器名字杀掉容器  </span></span><br><span class="line">docker <span class="built_in">kill</span> tomcat7  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据容器ID杀掉容器  </span></span><br><span class="line">docker <span class="built_in">kill</span> 65d4a94f7a39  </span><br></pre></td></tr></table></figure>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3>删除一个或多个容器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 强制删除容器 db01、db02：  </span></span><br><span class="line">docker <span class="built_in">rm</span> -f db01 db02  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器 nginx01, 并删除容器挂载的数据卷：  </span></span><br><span class="line">docker <span class="built_in">rm</span> -v nginx01  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有已经停止的容器：  </span></span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3>创建一个新的容器但不启动它。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用docker镜像nginx:latest创建一个容器,并将容器命名为mynginx  </span></span><br><span class="line">docker create --name mynginx nginx:latest     </span><br></pre></td></tr></table></figure>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3>在运行的容器中执行命令;也可以进入容器，可选参数</li>
<li>-d : 分离模式: 在后台运行</li>
<li>-i : 即使没有附加也保持STDIN 打开</li>
<li>-t : 分配一个伪终端<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在容器 mynginx 中以交互模式执行容器内 /root/nginx.sh 脚本  </span></span><br><span class="line">docker <span class="built_in">exec</span> -it mynginx /bin/sh /root/nginx.sh  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器 mynginx 中开启一个交互模式的终端</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t  mynginx /bin/bash  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。  </span></span><br><span class="line">docker ps -a   </span><br><span class="line">docker <span class="built_in">exec</span> -it 9df70f9a0714 /bin/bash  </span><br></pre></td></tr></table></figure>
<h3 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h3>当容器以后台模式运行时，需要进入容器，除了上述的exec，还有attach，但exec与attach有一个区别，当使用exec进入容器后推出，容器不会停止，但attach在退出后容器会停止，所以建议使用exec<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器id为1e560fca3906的容器</span></span><br><span class="line">docker attach 1e560fca3906 </span><br></pre></td></tr></table></figure>
<h3 id="pause-x2F-unpause"><a href="#pause-x2F-unpause" class="headerlink" title="pause&#x2F;unpause"></a>pause&#x2F;unpause</h3></li>
<li>docker pause :暂停容器中所有的进程。</li>
<li>docker unpause :恢复容器中所有的进程。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暂停数据库容器db01提供服务。  </span></span><br><span class="line">docker pause db01  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复数据库容器 db01 提供服务  </span></span><br><span class="line">docker unpause db0  </span><br></pre></td></tr></table></figure>
<h2 id="容器操作命令"><a href="#容器操作命令" class="headerlink" title="容器操作命令"></a>容器操作命令</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3>列出容器，可选参数：</li>
<li>-a : 显示所有的容器，包括未运行的。</li>
<li>-f : 根据条件过滤显示的内容。</li>
<li>–format : 指定返回值的模板文件。</li>
<li>-l : 显示最近创建的容器。</li>
<li>-n : 列出最近创建的n个容器。</li>
<li>–no-trunc : 不截断输出。</li>
<li>-q : 静默模式，只显示容器编号。</li>
<li>-s : 显示总的文件大小。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有在运行的容器信息。  </span></span><br><span class="line">docker ps  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出最近创建的5个容器信息。  </span></span><br><span class="line">docker ps -n 5  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有创建的容器ID。  </span></span><br><span class="line">docker ps -a -q  </span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">补充说明：容器的7种状态：created（已创建）、restarting（重启中）、running（运行中）、removing（迁移中）、paused（暂停）、exited（停止）、dead（死亡）。</span><br></pre></td></tr></table></figure>
<h2 id="未完，持续更新中"><a href="#未完，持续更新中" class="headerlink" title="未完，持续更新中"></a>未完，持续更新中</h2>More info: <a href="https://mp.weixin.qq.com/s/SfCEt9fHRz1TrVN39mH2iQ">docker常用命令</a></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>python不同平台进程的启动与终止</title>
    <url>/2022/05/31/python%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%88%E6%AD%A2/</url>
    <content><![CDATA[<h2 id="Liunx进程的启动与终止"><a href="#Liunx进程的启动与终止" class="headerlink" title="Liunx进程的启动与终止"></a>Liunx进程的启动与终止</h2><p>在使用subprocess创建进程时需要将所有进程设置为一个进程组<br>preexec_fn：只在 Unix 平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用<br>close_fds：在执行子进程之前,将关闭除0、1和2以外的所有文件描述符；表示子进程将不会继承父进程的输入、输出、错误管道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess, os, signal, time</span><br><span class="line"></span><br><span class="line">process_pid = None</span><br><span class="line"></span><br><span class="line"># linux</span><br><span class="line">def start_process():</span><br><span class="line">    command = &quot;adb shell&quot;</span><br><span class="line">    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, \</span><br><span class="line">        preexec_fn=os.setpgrp, close_fds=True)</span><br><span class="line">    print(&quot;adb shell&quot;)</span><br><span class="line">    global process_pid</span><br><span class="line">    process_pid = p.pid</span><br><span class="line">    print(process_pid)</span><br><span class="line"></span><br><span class="line">start_process()</span><br><span class="line">time.sleep(5)</span><br><span class="line">os.killpg(process_pid, signal.SIGKILL)</span><br></pre></td></tr></table></figure>
<h2 id="Windows进程的启动与终止"><a href="#Windows进程的启动与终止" class="headerlink" title="Windows进程的启动与终止"></a>Windows进程的启动与终止</h2><p>由于preexec_fn不适用于Windows系统，因此采取另外方式</p>
<h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>使用psutils遍历进程ID的子进程依次杀，此方法也适用于Linux系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进程开启</span><br><span class="line">import subprocess, psutil, time</span><br><span class="line">command = &quot;adb shell&quot;</span><br><span class="line">process = subprocess.Popen(command, shell=True, \</span><br><span class="line">    stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">process_id = process.pid</span><br><span class="line">print(process_id)</span><br><span class="line">print(&quot;adb shell&quot;)</span><br><span class="line"></span><br><span class="line"># 进程终止</span><br><span class="line">def kill(proc_pid):</span><br><span class="line">    parent_proc = psutil.Process(proc_pid)</span><br><span class="line">    # recursive=True：获取所有的父子进程</span><br><span class="line">    for child_proc in parent_proc.children(recursive=True):</span><br><span class="line">        child_proc.kill()</span><br><span class="line">    parent_proc.kill()</span><br><span class="line">time.sleep(5)</span><br><span class="line"></span><br><span class="line">kill(process_id)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>直接使用Windows的taskkill -t:进程树，-f:强制杀死</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /pid process_id -t -f</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python常用函数</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python socket理解</title>
    <url>/2022/05/29/python-socket%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。</p>
<h3 id="创建socket方式"><a href="#创建socket方式" class="headerlink" title="创建socket方式"></a>创建socket方式</h3><h4 id="普通创建"><a href="#普通创建" class="headerlink" title="普通创建"></a>普通创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket.socket(family=-1, type=-1, proto=-1, fileno=None):</span><br><span class="line">	family: 地址族：</span><br><span class="line">		AF_UNIX:unix本机通信</span><br><span class="line">		AF_INET: 默认值,ipv4</span><br><span class="line">		AF_INET6: 当程序使用到ipv6时使用</span><br><span class="line">	type: 套接字类型</span><br><span class="line">		SOCK_STREAM：默认值；基于tcp,可靠传输，适用于对消息内容要求的情况，例如文件下载等</span><br><span class="line">		SOCK_DGRAM：基于udp，广播消息，适用于对消息内容不是太准确的情况，例如视频通话、直播等</span><br><span class="line">		SOCK_RAW：</span><br><span class="line">	proto: 协议号编号</span><br><span class="line">		协议编号通常为零，可以省略，</span><br><span class="line">		或者在地址系列为AF_CAN的情况下，协议应为CAN_RAW、CAN_BCM、CAN_ISOTP或CAN_J1939之一。</span><br><span class="line">	fileno: 指定文件描述符</span><br><span class="line">		如果指定了fileno，则会从指定的文件描述符中自动检测family、type和proto的值，通常不会使用，此参数指定后，其他参数将失效</span><br></pre></td></tr></table></figure>
<h4 id="创建一对已经连接的套接字对象"><a href="#创建一对已经连接的套接字对象" class="headerlink" title="创建一对已经连接的套接字对象"></a>创建一对已经连接的套接字对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socketpair(family=None, type=SOCK_STREAM, proto=0)</span><br><span class="line">	相当于创建一对已经连接的socket套接字,包含server和client</span><br><span class="line">	默认是全双工模式,既可以发,也可以收</span><br><span class="line">	默认是创建unix套接字(AF_UNIX)</span><br><span class="line">	参数与socket基本一致</span><br><span class="line">	使用场景：</span><br><span class="line">		import socket</span><br><span class="line">		from multiprocessing import Process, Pipe</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		进程间双向通信, 相当于进程间通信的PIPE，只支持Linux</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		socket1, socket2 = socket.socketpair()</span><br><span class="line">		def process1():</span><br><span class="line">			print(socket1)</span><br><span class="line">			print(socket2)</span><br><span class="line">			# 关闭不需要的socket</span><br><span class="line">			socket2.close()</span><br><span class="line">			socket1.send(b&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">		def process2():</span><br><span class="line">			print(socket1)</span><br><span class="line">			socket1.close()</span><br><span class="line">			print(socket2)</span><br><span class="line">			print(socket2.recv(1024))</span><br><span class="line">		</span><br><span class="line">		# pipe　简易使用</span><br><span class="line">		conn1, conn2 = Pipe()</span><br><span class="line">		def process3():</span><br><span class="line">			print(conn1)</span><br><span class="line">			conn1.send(b&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">		def process4():</span><br><span class="line">			print(conn2)</span><br><span class="line">			print(conn2.recv())</span><br><span class="line">		if __name__ == &quot;__main__&quot;:</span><br><span class="line">			p1 = Process(target=process1)</span><br><span class="line">			p2 = Process(target=process2)</span><br><span class="line">			p1.start()</span><br><span class="line">			p2.start()</span><br><span class="line">			p3 = Process(target=process3)</span><br><span class="line">			p4 = Process(target=process4)</span><br><span class="line">			p3.start()</span><br><span class="line">			p4.start()</span><br><span class="line">－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		线程间双向通信:支持;Linux\Windows</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		import threading</span><br><span class="line">		socket1, socket2 = socket.socketpair()</span><br><span class="line">		def thread1():</span><br><span class="line">			print(socket1)</span><br><span class="line">			socket1.send(b&quot;hello&quot;)</span><br><span class="line">		def thread2():</span><br><span class="line">			print(socket2)</span><br><span class="line">			print(socket2.recv(1024))</span><br><span class="line"></span><br><span class="line">		t1 = threading.Thread(target=thread1)</span><br><span class="line">		t2 = threading.Thread(target=thread2)</span><br><span class="line">		t1.start()</span><br><span class="line">		t2.start()</span><br></pre></td></tr></table></figure>
<h4 id="创建连接基于tcp的socket对象-客户端"><a href="#创建连接基于tcp的socket对象-客户端" class="headerlink" title="创建连接基于tcp的socket对象(客户端)"></a>创建连接基于tcp的socket对象(客户端)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None)</span><br><span class="line">	address: 需要连接的tcp服务的地址(host, port)</span><br><span class="line">	timeout: 连接的超时时间</span><br><span class="line">	source_address: 将socket对象绑定到对应地址上(host, port),会在服务端上显示对应此地址</span><br><span class="line">	只支持tcp,udp无法连接</span><br><span class="line">	它将尝试为AF_INET和AF_INET6解析它，然后尝试依次连接到所有可能的地址，直到连接成功。</span><br><span class="line">	这使得编写同时兼容IPv4和IPv6的客户端变得容易。</span><br></pre></td></tr></table></figure>
<h4 id="创建基于tcp的socket对象-服务端-，python需在3-8以上"><a href="#创建基于tcp的socket对象-服务端-，python需在3-8以上" class="headerlink" title="创建基于tcp的socket对象(服务端)，python需在3.8以上"></a>创建基于tcp的socket对象(服务端)，python需在3.8以上</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create_server(address, *, family=AF_INET, backlog=None, reuse_port=False, dualstack_ipv6=False)</span><br><span class="line">	address: 绑定的地址</span><br><span class="line">	family: 地址族: AF_INET or AF_INET6</span><br><span class="line">	backlog: 监听的队列数，相当于 socket.listen()</span><br><span class="line">	reuse_port: 指示是否使用SO_REUSEPORT套接字选项; SO_REUSEPORT: 重用端口</span><br><span class="line">	dualstack_ipv6: 是否支持ipv6, 如果为True, 则family必须为AF_INET6,如果设备支持，则可以同事接收ipv4和ipv6的数据</span><br><span class="line">	实例：</span><br><span class="line">		with create_server((&#x27;&#x27;, 8000)) as server:</span><br><span class="line">		...     while True:</span><br><span class="line">		...         conn, addr = server.accept()</span><br><span class="line">		...         # handle new connection</span><br><span class="line">不需要手动绑定监听，方便了不少</span><br><span class="line">在POSIX平台上，设置了SO\u REUSEADDR socket选项，以便立即重用以前绑定在同一地址上并保持TIME\u WAIT状态的套接字。</span><br></pre></td></tr></table></figure>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3.8以上支持:  如果平台支持处理tcp的ipv4和ipv6的连接，则返回True, 否则返回False</span><br><span class="line">socket.has_dualstack_ipv6()</span><br><span class="line"># 从给定的文件副本中创建套接字对象，fd:文件副本, 其余与socket一致</span><br><span class="line">socket.fromfd(fd, family, type, proto=0)</span><br><span class="line"># 从socket.share()中创建套接字,此套接字默认是阻塞的 只支持windows</span><br><span class="line">socket.fromshare()</span><br><span class="line"># 关闭文件描述符, python 3.7新增;类似于os.close,但对于socket来说，在一些平台上，尤其是windows平台，无法正常关闭文件描述符</span><br><span class="line">socket.close()</span><br><span class="line"># 将主机和端口解析为地址信息条目列表。返回的为(family, type, proto, canonname, sockaddr)元组</span><br><span class="line">socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)</span><br><span class="line"># 从名称中获取完整的域名，name为空或为0.0.0.0则调用gethostname返回主机名，如果name不为空，则调用gethostbyaddr根据地址获取主机名</span><br><span class="line">socket.getfqdn(name=&#x27;&#x27;)</span><br><span class="line">socket.gethostname()</span><br><span class="line"># 此处的name类似于address</span><br><span class="line">socket.gethostbyaddr(name)</span><br><span class="line">不常用方法更多详见官网</span><br></pre></td></tr></table></figure>
<h4 id="socket方法"><a href="#socket方法" class="headerlink" title="socket方法"></a>socket方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 接受连接。套接字必须绑定到地址并侦听连接。返回值是一对（conn，address），其中conn是一个新的套接字对象，可用于在连接上发送和接收数据，address是绑定到连接另一端的套接字的地址。　一般为服务端</span><br><span class="line">socket.accept()</span><br><span class="line"># 将套接字绑定到地址, address:(host, port)　一般为服务端</span><br><span class="line">socket.bind(address)</span><br><span class="line"># 关闭socket连接，注意在socket使用完后最好关闭socket</span><br><span class="line">socket.close()</span><br><span class="line"># 连接远程的地址, 如果超时，则会报超时TimeoutError，出现信号异常时会抛出InterruptedError, 一般为客户端</span><br><span class="line">socket.connect(address)</span><br><span class="line"># 连接远程的地址, 但对于C-level connect（）调用返回的错误，返回一个错误指示符，而不是引发异常（其他问题，例如“找不到主机”，仍然可能引发异常）。如果操作成功，错误指示器为0，否则为errno变量的值。这对于支持异步连接非常有用。一般为客户端</span><br><span class="line">socket.connect_ex(address)</span><br><span class="line"># 将套接字对象置于关闭状态，而不实际关闭底层文件描述符。文件描述符将被返回，并可用于其他目的。</span><br><span class="line">socket.detach()</span><br><span class="line"># 复制socket</span><br><span class="line">socket.dup()</span><br><span class="line"># 返回套接字的文件描述符（一个小整数），失败时返回-1。这对select.select()很有用</span><br><span class="line">socket.fileno()</span><br><span class="line"># 获取套接字的文件描述符或套接字句柄的可继承标志：如果套接字可以在子进程中继承，则为True；如果不能，则为False。</span><br><span class="line">socket.get_inheritable()</span><br><span class="line"># 返回套接字连接的远程地址。(host, port); 例如，这对于查找远程IPv4/v6套接字的端口号很有用。在某些系统上不支持此功能。一般为客户端</span><br><span class="line">socket.getpeername()</span><br><span class="line"># 返回套接字自己的地址。例如，这对于查找IPv4/v6套接字的端口号很有用。主机自身的</span><br><span class="line">socket.getsockname()</span><br><span class="line"># 返回给定套接字选项的值（请参阅Unix手册页getsockopt（2））。所需的符号常数（SO_*等）在本模块中定义。如果不存在buflen，则假定一个整数选项，其整数值由函数返回。如果存在buflen，它将指定用于在中接收选项的缓冲区的最大长度，该缓冲区将作为字节对象返回。由调用者来解码缓冲区的内容（请参阅可选的内置模块struct，了解解码编码为字节字符串的C结构的方法）。</span><br><span class="line">socket.getsockopt(level, optname[, buflen])</span><br><span class="line"># 如果套接字处于阻塞模式，则返回True；如果处于非阻塞模式，则返回False。python 3.7新增</span><br><span class="line">socket.getblocking()</span><br><span class="line"># 返回与套接字操作相关的超时（以秒为单位），如果未设置超时，则返回无。这反映了对setblocking（）或settimeout（）的最后一次调用。</span><br><span class="line">socket.gettimeout()</span><br><span class="line"># WSAIoctl系统接口的有限接口。只支持windows;有关更多信息，请参阅Win32文档。在其他平台上，通用fcntl。fcntl（）和fcntl。可以使用ioctl（）函数；它们接受套接字对象作为第一个参数。目前只支持以下控制代码：SIO_RCVALL、SIO_KEEPALIVE_VALS和SIO_LOOPBACK_FAST_PATH。</span><br><span class="line">socket.ioctl(control, option)</span><br><span class="line"># 允许服务器接受连接。如果指定了backlog，则它必须至少为0（如果较低，则设置为0）；它指定系统在拒绝新连接之前允许的未接受连接数。如果未指定，则选择默认的合理值。</span><br><span class="line">socket.listen(backlog)；一般用于服务端</span><br><span class="line"># 返回与套接字关联的文件对象。返回的确切类型取决于makefile（）的参数。这些参数的解释方式与内置的open（）函数相同，只是支持的模式值只有&#x27;r&#x27;（默认值）、&#x27;w&#x27;和&#x27;b&#x27;。插座必须处于阻塞模式；它可以有一个超时，但如果超时，文件对象的内部缓冲区可能会以不一致的状态结束。关闭makefile（）返回的文件对象不会关闭原始套接字，除非所有其他文件对象都已关闭，并且已打开套接字。已对套接字对象调用close（）。</span><br><span class="line">socket.makefile(mode=&#x27;r&#x27;, buffering=None, *, encoding=None, errors=None, newline=None)</span><br><span class="line"># 从套接字接收数据。返回值是一个字节对象，表示接收到的数据。一次接收的最大数据量由bufsize指定。有关可选参数标志的含，一般用于tcp连接</span><br><span class="line">socket.recv(bufsize, flags);</span><br><span class="line"># 从套接字接收数据。返回值是一对（字节，地址），其中字节是表示接收到的数据的字节对象，地址是发送数据的套接字的地址,一般用于udp连接的客户端</span><br><span class="line">socket.recvfrom(bufsize, flags)</span><br><span class="line"></span><br><span class="line"># 不太熟悉</span><br><span class="line">socket.recvmsg(bufsize[, ancbufsize[, flags]])</span><br><span class="line">socket.recvmsg_into(buffers[, ancbufsize[, flags]])</span><br><span class="line"># 从套接字接收数据，将其写入缓冲区，而不是创建新的bytestring。返回值是一对（nbytes，address），其中nbytes是接收的字节数，address是发送数据的套接字的地址。</span><br><span class="line">socket.recvfrom_into(buffer[, nbytes[, flags]])</span><br><span class="line">socket.recv_into(buffer[, nbytes[, flags]])¶</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 发送字节数据到远程的socket，返回发送数据的字节数，一般用于客户端，可能会出现返回的字节数小于实际的发送数，当数据未发送完成时，需由应用程序检查是否完成发送，所以需要重复发送数据，</span><br><span class="line">socket.send(bytes, flags)</span><br><span class="line"># 发送字节数据到远程的socket,一般用于客户端，持续发送，无法确认发送了多少数据</span><br><span class="line">socket.sendall(bytes[, flags])</span><br><span class="line"># 发送字节数据，不需要连接远程的socket, 指定发送的地址，udp发送，点对点, 返回发送数据的字节数</span><br><span class="line">socket.sendto(bytes, flags, address)</span><br><span class="line"></span><br><span class="line"># 不太熟悉</span><br><span class="line">socket.sendmsg(buffers[, ancdata[, flags[, address]]])</span><br><span class="line">socket.sendmsg_afalg([msg, ]*, op[, iv[, assoclen[, flags]]])</span><br><span class="line">socket.sendfile(file, offset=0, count=None)</span><br><span class="line">socket.set_inheritable(inheritable)</span><br><span class="line"></span><br><span class="line"># 设置套接字的阻塞或非阻塞模式：如果标志为false，则将套接字设置为非阻塞，否则设置为阻塞模式。</span><br><span class="line">socket.setblocking(flag)</span><br><span class="line"># 设置连接超时时间，作用同上, python3.7后socket type已添加SOCK_NONBLOCK flag </span><br><span class="line">socket.settimeout(value)</span><br><span class="line">sock.setblocking(True) 相当于sock.settimeout(None)</span><br><span class="line">sock.setblocking(False) 相当于sock.settimeout(0.0)</span><br><span class="line"></span><br><span class="line"># 对socket的拓展，作用于套接字，设置套接字的相关属性</span><br><span class="line">socket.setsockopt(level, optname, None, optlen: int)</span><br><span class="line"></span><br><span class="line"># 关闭连接，发送和接收，how为SHUT_RD，接收不被允许；how为SHUT_WR，发送不被允许；how为SHUT_RDWR，发送接收都不被允许，一般建议先close在shutdown, 保证数据完全发送</span><br><span class="line">socket.shutdown(how)</span><br><span class="line"># 复制套接字并准备与目标进程共享。必须为目标进程提供进程id。然后，可以使用某种形式的进程间通信将生成的字节对象传递给目标进程，并使用fromshare（）在那里重新创建套接字。一旦调用了这个方法，就可以安全地关闭套接字，因为操作系统已经为目标进程复制了它。</span><br><span class="line">socket.share(process_id)</span><br></pre></td></tr></table></figure>
<h4 id="套接字创建注意事项"><a href="#套接字创建注意事项" class="headerlink" title="套接字创建注意事项"></a>套接字创建注意事项</h4><p>套接字对象可以采用三种模式之一：阻塞、非阻塞或超时。默认情况下，套接字始终在阻塞模式下创建，但可以通过调用setdefaulttimeout（）来更改。<br>　　在阻塞模式下，操作会阻塞直到完成或系统返回错误（例如连接超时）。<br>　　在非阻塞模式下，如果操作不能立即完成，操作将失败（不幸的是，错误取决于系统）：来自 的函数 select可用于了解套接字何时以及是否可用于读取或写入。<br>　　在超时模式下，如果无法在为套接字指定的超时时间内完成操作（它们引发timeout异常）或系统返回错误，则操作将失败。<br>　　在操作系统级别，超时模式下的套接字在内部设置为非阻塞模式。此外，阻塞和超时模式在引用同一网络端点的文件描述符和套接字对象之间共享。如果您决定使用套接字的fileno（），此实现细节可能会产生明显的后果。</p>
<h5 id="超时和connect方法"><a href="#超时和connect方法" class="headerlink" title="超时和connect方法"></a>超时和connect方法</h5><p>connect（）操作也受超时设置的影响，通常建议在调用connect之前调用settimeout，或传递超时参数到create_connection。然而，无论Python套接字超时设置如何，系统网络堆栈也可能返回自己的连接超时错误。</p>
<h5 id="超时和accept方法"><a href="#超时和accept方法" class="headerlink" title="超时和accept方法"></a>超时和accept方法</h5><p>如果getdefaulttimeout（）不是None，则accept（）方法返回的套接字将继承该超时。否则，行为取决于监听套接字的设置：<br>如果监听套接字处于阻塞模式或超时模式，则accept（）返回的套接字处于阻塞模式；<br>如果侦听套接字处于非阻塞模式，则accept（）返回的套接字是处于阻塞模式还是非阻塞模式取决于操作系统。如果要确保跨平台行为，建议手动覆盖此设置。</p>
<h4 id="recv-send等相关携带flag参数展示"><a href="#recv-send等相关携带flag参数展示" class="headerlink" title="recv, send等相关携带flag参数展示"></a>recv, send等相关携带flag参数展示</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用SCM_权限操作（如UNIX（7）所述），为通过UNIX域文件描述符接收的文件描述符设置close on exec标志。该标志的用途与open（2）的O_CLOEXEC标志相同。</span><br><span class="line">MSG_CMSG_CLOEXEC (recvmsg() only; since Linux 2.6.23) </span><br><span class="line"># 启用非阻塞操作；如果操作会阻塞，则调用会失败，并出现错误EAGAIN或EWOLDBLOCK。</span><br><span class="line">MSG_DONTWAIT (since Linux 2.2) </span><br><span class="line"># 此标志指定应从套接字错误队列接收排队的错误。错误在一条辅助消息中传递，其类型取决于协议（对于IPv4 IP_RECVERR）。用户应提供足够大小的缓冲区。</span><br><span class="line">MSG_ERRQUEUE (since Linux 2.2) </span><br><span class="line"># 此标志请求接收正常数据流中不会接收到的带外数据。一些协议将加速数据放在正常数据队列的前端，因此该标志不能与此类协议一起使用。</span><br><span class="line">MSG_OOB</span><br><span class="line"># 此标志使接收操作从接收队列的开头返回数据，而不从队列中删除该数据。因此，后续的接收呼叫将返回相同的数据。</span><br><span class="line">MSG_PEEK</span><br><span class="line"># 对于原始（AF_数据包）、Internet数据报（自Linux 2.4.27/2.6.8起）、netlink（自Linux 2.6.22起）和UNIX数据报（自Linux 3.4起）套接字：返回数据包或数据报的实际长度，即使它比传递的缓冲区长。</span><br><span class="line">MSG_TRUNC (since Linux 2.2)</span><br><span class="line"># 此标志请求操作块停止，直到满足完整请求。然而，如果捕捉到信号、发生错误或断开连接，或者要接收的下一个数据与返回的数据类型不同，则呼叫返回的数据可能仍然少于请求的数据。此标志对数据报套接字无效。对于接收大数据</span><br><span class="line">MSG_WAITALL (since Linux 2.2) </span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="一对一发送：只能接收一次：tcp，接收完自动停止"><a href="#一对一发送：只能接收一次：tcp，接收完自动停止" class="headerlink" title="一对一发送：只能接收一次：tcp，接收完自动停止"></a>一对一发送：只能接收一次：tcp，接收完自动停止</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;192.168.57.207&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.sendall(b&quot;hello&quot;)</span><br><span class="line">    reply_data = client.recv(BUFFERSIZE)</span><br><span class="line">    print(f&quot;reply_data:&#123;reply_data&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def connect_one_once():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    一对一发送:只能接收一次</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:</span><br><span class="line">        server.bind((HOST, PORT))</span><br><span class="line">        server.listen(4)</span><br><span class="line">        print(&quot;server start&quot;)</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        with conn:</span><br><span class="line">            print(f&quot;connect addr:&#123;addr&#125;&quot;)</span><br><span class="line">            while True:</span><br><span class="line">                data = conn.recv(BUFFERSIZE)</span><br><span class="line">                if data:</span><br><span class="line">                    break</span><br><span class="line">                print(f&quot;server receive data:&#123;data&#125;&quot;)</span><br><span class="line">                conn.send(data)</span><br></pre></td></tr></table></figure>
<h4 id="一对多发送：可以接收一次：tcp，接收完可以继续接收，不过默认socket会阻塞"><a href="#一对多发送：可以接收一次：tcp，接收完可以继续接收，不过默认socket会阻塞" class="headerlink" title="一对多发送：可以接收一次：tcp，接收完可以继续接收，不过默认socket会阻塞"></a>一对多发送：可以接收一次：tcp，接收完可以继续接收，不过默认socket会阻塞</h4><h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><p>同上客户端</p>
<h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def connect_muti_more():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    一对多发送:可接收多次</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import time</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:</span><br><span class="line">        server.bind((HOST, PORT))</span><br><span class="line">        server.listen(4)</span><br><span class="line">        print(&quot;server start&quot;)</span><br><span class="line">        while True:</span><br><span class="line">            conn, addr = server.accept()      </span><br><span class="line">            with conn:</span><br><span class="line">                print(f&quot;connect addr:&#123;addr&#125;&quot;)</span><br><span class="line">                data = conn.recv(BUFFERSIZE)</span><br><span class="line">                time.sleep(20)      </span><br><span class="line">                print(f&quot;server receive data:&#123;data&#125;&quot;)</span><br><span class="line">                conn.send(data)</span><br></pre></td></tr></table></figure>
<h4 id="socket发送大数据及接收数据"><a href="#socket发送大数据及接收数据" class="headerlink" title="socket发送大数据及接收数据"></a>socket发送大数据及接收数据</h4><h5 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h5><p>同上，只是数据超过可buffersize</p>
<h5 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def connect_muti_large():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    发送大数据</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import time</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:</span><br><span class="line">        server.bind((HOST, PORT))</span><br><span class="line">        server.listen(4)</span><br><span class="line">        print(&quot;server start&quot;)</span><br><span class="line">        while True:</span><br><span class="line">            conn, addr = server.accept()      </span><br><span class="line">            print(f&quot;connect addr:&#123;addr&#125;&quot;)</span><br><span class="line">            while True:</span><br><span class="line">                data = conn.recv(BUFFERSIZE, socket.MSG_WAITALL)</span><br><span class="line">                if not data: break</span><br><span class="line">                print(f&quot;server receive data:&#123;data&#125;&quot;)</span><br><span class="line">                conn.send(data)</span><br></pre></td></tr></table></figure>
<h4 id="udp通信"><a href="#udp通信" class="headerlink" title="udp通信"></a>udp通信</h4><h5 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h5><p>udp无需连接对应地址，直接进行点对点发送即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;192.168.57.207&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client:</span><br><span class="line">    client.sendto(b&quot;world&quot;, (HOST, PORT))</span><br></pre></td></tr></table></figure>
<h5 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h5><p>服务端无需监听端口，直接接收对应数据即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def connect_udp():</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as server:</span><br><span class="line">        server.bind((HOST, PORT))</span><br><span class="line">        data = server.recvfrom(BUFFERSIZE)</span><br><span class="line">        print(f&quot;receive data:&#123;data&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="局域网udp广播"><a href="#局域网udp广播" class="headerlink" title="局域网udp广播"></a>局域网udp广播</h3><p>实现同一局域网，广播传播消息，同一设备的客户端只能绑定一个，可通过server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)实现多个文件同一设备绑定同一个端口</p>
<h4 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;&lt;broadcast&gt;&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def udp_server():</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client:</span><br><span class="line">        client.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)</span><br><span class="line">        data = &quot;hello&quot;</span><br><span class="line">        client.sendto(data.encode(&quot;utf-8&quot;), (HOST, PORT))</span><br><span class="line">        </span><br><span class="line">udp_server()</span><br></pre></td></tr></table></figure>
<h4 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4003</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def udp():</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as server:</span><br><span class="line">　　# 一台机器可绑定同一个端口</span><br><span class="line">        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">        server.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)</span><br><span class="line">        server.bind((HOST, PORT))</span><br><span class="line">        while True:</span><br><span class="line">            data, addr = server.recvfrom(BUFFERSIZE)</span><br><span class="line">            print(f&quot;addr:&#123;addr&#125;, data:&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line">udp()</span><br></pre></td></tr></table></figure>
<h3 id="一（服务端）对多（客户端）通信"><a href="#一（服务端）对多（客户端）通信" class="headerlink" title="一（服务端）对多（客户端）通信"></a>一（服务端）对多（客户端）通信</h3><p>默认情况下，socket是阻塞的，意思就是服务端在接收到一个客户端的请求后必须要处理完，下一个客户端才可以连接，为了确保一对多的连接，可以采用多线程、socketServer、selectIO多路复用等方式实现一对多通信</p>
<h3 id="客户端-5"><a href="#客户端-5" class="headerlink" title="客户端"></a>客户端</h3><p>可以使用多个客户端来测试服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;192.168.xx.xxx&quot;</span><br><span class="line">PORT = 4001</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.send(b&quot;hello&quot;)</span><br><span class="line">    data = client.recv(BUFFERSIZE)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<h4 id="多线程方式"><a href="#多线程方式" class="headerlink" title="多线程方式"></a>多线程方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket, time,threading</span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4001</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def recv_msg(server):</span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    print(f&quot;addr:&#123;addr&#125;&quot;)</span><br><span class="line">    data = conn.recv(BUFFERSIZE)</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print(f&quot;data:&#123;data&#125;&quot;)</span><br><span class="line">    conn.send(data)</span><br><span class="line"></span><br><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:</span><br><span class="line">    server.bind((HOST, PORT))</span><br><span class="line">    server.listen(10)</span><br><span class="line">    while True:</span><br><span class="line">        t = threading.Thread(target=recv_msg, args=(server,))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h4 id="重写socketServer"><a href="#重写socketServer" class="headerlink" title="重写socketServer"></a>重写socketServer</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socketserver</span><br><span class="line"></span><br><span class="line">class MySocketServer(socketserver.BaseRequestHandler):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">        def __init__(self, request, client_address, server):</span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        try:</span><br><span class="line">            self.handle()</span><br><span class="line">        finally:</span><br><span class="line">            self.finish()</span><br><span class="line"></span><br><span class="line">    def setup(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def handle(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def finish(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def setup(self) -&gt; None:</span><br><span class="line">        print(f&quot;request:&#123;self.request&#125;&quot;)</span><br><span class="line">        print(f&quot;client_address:&#123;self.client_address&#125;&quot;)</span><br><span class="line">        print(f&quot;server:&#123;self.server&#125;&quot;)</span><br><span class="line">        return super().setup()</span><br><span class="line">    </span><br><span class="line">    def handle(self) -&gt; None:</span><br><span class="line">        data = self.request.recv(BUFFERSIZE)</span><br><span class="line">        print(f&quot;data:&#123;data&#125;&quot;)</span><br><span class="line">        time.sleep(10)</span><br><span class="line">        self.request.send(data)</span><br><span class="line">        return super().handle()</span><br><span class="line"># 与默认的socket一样，也会阻塞</span><br><span class="line"># server = socketserver.TCPServer((HOST, PORT), RequestHandlerClass=MySocketServer)</span><br><span class="line"># 使用类似创建线程的方式，避免阻塞， Windows、Linux通用</span><br><span class="line">server = socketserver.ThreadingTCPServer((HOST, PORT), RequestHandlerClass=MySocketServer)</span><br><span class="line"># 使用创建进程的方式。避免阻塞，只适用于Linux</span><br><span class="line"># server = socketserver.ForkingTCPServer((HOST, PORT), RequestHandlerClass=MySocketServer)</span><br><span class="line"># serve_forever(self, poll_interval=0.5)：每隔固定时间进行轮训， 默认0.5</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure>
<h4 id="select-IO多路复用"><a href="#select-IO多路复用" class="headerlink" title="select IO多路复用"></a>select IO多路复用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import select, socket</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4001</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 设置共用地址端口，防止出现冲突</span><br><span class="line">server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">server.setblocking(False)</span><br><span class="line">server.bind((HOST, PORT))</span><br><span class="line">server.listen(10)</span><br><span class="line"></span><br><span class="line"># 依次轮询readable、writeable、exceptional</span><br><span class="line"># 期望去读的服务端socket以及服务端接收到的客户端的socket</span><br><span class="line">inputs = [server]</span><br><span class="line"># 期望去写的socket（客户端）发送数据</span><br><span class="line">outputs = []</span><br><span class="line"># 存放发送接收消息的字典</span><br><span class="line">message_queue = &#123;&#125;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">readable, writeable, exceptional = select.select(inputs, outputs, inputs, timeout)</span><br><span class="line">    inputs: 监听可读的套接字 外部发来的数据，服务端接收的客户端</span><br><span class="line">    outputs: 监听可写的套接字 监控并接收所有发出去的数据</span><br><span class="line">    inputs: 监听错误信息 </span><br><span class="line">    timeout: 监听的时间限制 默认是0.05</span><br><span class="line">    readable: 可读列表 服务端socket, 以及默认接收的客户端</span><br><span class="line">    writeable: 可写列表 运行过程产生的socket 服务端接收的客户端</span><br><span class="line">    exceptional: 错误信息  异常列表</span><br><span class="line">readable对应inputs中数据</span><br><span class="line">writeable对应outputs数据</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">while inputs:</span><br><span class="line">    # 服务端socket，运行过程产生的socket：客户端，异常列表</span><br><span class="line">    readable, writeable, exceptional = select.select(inputs, outputs, inputs)</span><br><span class="line">    # 处理服务器端的socket及包括接收到的客户端socket</span><br><span class="line">    for s in readable:</span><br><span class="line">        if s is server:</span><br><span class="line">            # 服务端本身</span><br><span class="line">            conn, addr = s.accept()</span><br><span class="line">            # 设置非阻塞</span><br><span class="line">            conn.setblocking(False)</span><br><span class="line">            # 将接受到的socket添加到</span><br><span class="line">            inputs.append(conn)</span><br><span class="line">            message_queue[conn] = Queue()</span><br><span class="line">        else:</span><br><span class="line">            # 服务端接收的客户端的socket：inputs.append(conn)</span><br><span class="line">            data = s.recv(BUFFERSIZE)</span><br><span class="line">            print(f&quot;&#123;s.getpeername()&#125;  recv data:&#123;data&#125;&quot;)</span><br><span class="line">            if data:</span><br><span class="line">                # 客户端与服务端保持连接，客户端向服务端发送数据</span><br><span class="line">                message_queue[s].put(data)</span><br><span class="line">                # 将接收的客户端添加到outputs用于服务端向客户端发送数据</span><br><span class="line">                if s not in outputs:</span><br><span class="line">                    outputs.append(s)</span><br><span class="line">            else:</span><br><span class="line">                # 无消息接收，客户端与服务端断开连接</span><br><span class="line">                # 删除outputs中将要发送消息的socket</span><br><span class="line">                if s in outputs:</span><br><span class="line">                    outputs.remove(s)</span><br><span class="line">                if s in inputs:</span><br><span class="line">                    inputs.remove(s)</span><br><span class="line">                # 关闭客户端socket</span><br><span class="line">                s.close()</span><br><span class="line">                # 清除消息字典中的对应socket</span><br><span class="line">                del message_queue[s]</span><br><span class="line"></span><br><span class="line">    # 连接到服务端的conn 服务端向客户端发送数据</span><br><span class="line">    for s in writeable:</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            message = message_queue.get(s, None)</span><br><span class="line">            if message is not None:</span><br><span class="line">                # 从消息字典中拿取数据</span><br><span class="line">                data = message.get_nowait()</span><br><span class="line">            else:</span><br><span class="line">                # 消息字典中无对应数据, 客户端断开</span><br><span class="line">                print(f&quot;socket has no data , close&quot;)</span><br><span class="line">                # if s in outputs:</span><br><span class="line">                #     outputs.remove(s)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            # 客户端断开</span><br><span class="line">            print(f&quot;send data error&quot;)</span><br><span class="line">            print(f&quot;&#123;s.getpeername()&#125; close&quot;)</span><br><span class="line">        else:</span><br><span class="line">            # 如果存在对应消息字典数据则发送</span><br><span class="line">            if message is not None:</span><br><span class="line">                s.send(data)</span><br><span class="line">            else:</span><br><span class="line">                print(f&quot;socket has no data , close&quot;)</span><br><span class="line"></span><br><span class="line">    # 异常处理</span><br><span class="line">    for s in exceptional:</span><br><span class="line">        print(&quot;exist exception&quot;)</span><br><span class="line">        # 出现异常，从inputs删除socket</span><br><span class="line">        inputs.remove(s)</span><br><span class="line">        # 如果在outputs中存在则删除</span><br><span class="line">        if s in outputs:</span><br><span class="line">            outputs.remove(s)</span><br><span class="line">        if s in inputs:</span><br><span class="line">            inputs.remove(s)</span><br><span class="line">        # 关闭socket</span><br><span class="line">        s.close()</span><br><span class="line">        # 删除socket相应的消息字典数据</span><br><span class="line">        del message_queue[s]</span><br><span class="line">        </span><br><span class="line">    # print(readable)</span><br><span class="line">    # print(writeable)</span><br><span class="line">    # print(exceptional)</span><br></pre></td></tr></table></figure>
<h4 id="select服务端接收客户端的一次流程"><a href="#select服务端接收客户端的一次流程" class="headerlink" title="select服务端接收客户端的一次流程"></a>select服务端接收客户端的一次流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select接收一次客户端流程</span><br><span class="line">第一次轮询：服务端</span><br><span class="line">    inputs:[服务端socket]</span><br><span class="line">    outputs:[]</span><br><span class="line">	readable:[服务端socket]</span><br><span class="line">	writeable:[]</span><br><span class="line">	exceptional:[]</span><br><span class="line">	轮询监听的服务端socket，将接收到的客户端添加至监听可读列表 ,并对客户端创建消息队列并添加至消息字典中</span><br><span class="line">    inputs:[服务端socket, 接收到的客户端socket]</span><br><span class="line">第二次轮询：服务端接收到的客户端， 接收消息</span><br><span class="line">    inputs:[服务端socket, 接收到的客户端socket]</span><br><span class="line">    outputs:[]</span><br><span class="line">    readable:[接收到的客户端socket]</span><br><span class="line">    writeable:[]</span><br><span class="line">    exceptional:[]</span><br><span class="line">    轮询监听接收到的客户端的socket， 接收客户端的数据并将数据添加至对应消息队列中</span><br><span class="line">    outputs:[接收到的客户端socket]</span><br><span class="line">    readable:[]</span><br><span class="line">第三次轮询：服务端接收到的客户端， 服务端发送消息给客户端</span><br><span class="line">    inputs:[服务端socket, 接收到的客户端socket]</span><br><span class="line">    outputs:[接收到的客户端socket]</span><br><span class="line">    readable:[]</span><br><span class="line">    writeable:[接收到的客户端socket]</span><br><span class="line">    exceptional:[]</span><br><span class="line">    接收到的客户端socket获取消息队列中的数据并向客户端发送数据</span><br><span class="line"></span><br><span class="line">第四次轮询：</span><br><span class="line">    inputs:[服务端socket, 接收到的客户端socket]</span><br><span class="line">    outputs:[接收到的客户端socket]</span><br><span class="line">    readable:[接收到的客户端socket]</span><br><span class="line">    writeable:[接收到的客户端socket]</span><br><span class="line">    exceptional:[]</span><br><span class="line">    继续接收数据，由于没有数据则从可写（发送数据）列表、可读列表（服务端接收）中移除并关闭客户端socket、删除对应消息字典中的队列</span><br><span class="line">    inputs:[服务端socket]</span><br><span class="line">    outputs:[]</span><br><span class="line">    readable:[接收到的客户端socket(closed)]</span><br><span class="line">    writeable:[接收到的客户端socket(closed)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="检测端口是否被占用"><a href="#检测端口是否被占用" class="headerlink" title="检测端口是否被占用"></a>检测端口是否被占用</h3><p>通过连接对应端口，是否出现目标计算机拒绝来判断端口是否被占用，被占用则返回True，反之则为False，无需在执行命令查看端口是否被占用<br>Windows查看端口占用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr port</span><br></pre></td></tr></table></figure>
<p>Linux查看端口占用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof -i:port</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def check_port_used(port):</span><br><span class="line">    try:</span><br><span class="line">        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        client.connect((&quot;127.0.0.1&quot;, port))</span><br><span class="line">        return True</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;check_port_used error:&#123;e&#125;&quot;)</span><br><span class="line">        return False</span><br><span class="line">    finally:</span><br><span class="line">        client.close()</span><br></pre></td></tr></table></figure>

<h3 id="跨语言通信（同一台设备），不同设备的采用RPC"><a href="#跨语言通信（同一台设备），不同设备的采用RPC" class="headerlink" title="跨语言通信（同一台设备），不同设备的采用RPC"></a>跨语言通信（同一台设备），不同设备的采用RPC</h3><p>需要注意的是如果使用bufferedReader.readLine()读取服务端发送的数据时默认回阻塞，只有读到\n或者\r时才会返回</p>
<h4 id="python服务端"><a href="#python服务端" class="headerlink" title="python服务端"></a>python服务端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import time</span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4001</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def socket_demo_tcp():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    socket.socket(family=-1, type=-1, proto=-1, fileno=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)</span><br><span class="line">    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    server_socket.bind((HOST, PORT))</span><br><span class="line">    server_socket.listen(1)</span><br><span class="line">    while True:</span><br><span class="line">        conns, address = server_socket.accept()</span><br><span class="line">        print(f&quot;conns:&#123;conns&#125;, address:&#123;address&#125;&quot;)</span><br><span class="line">        msg = conns.recv(BUFFERSIZE)</span><br><span class="line">        time.sleep(5)</span><br><span class="line">        print(f&quot;msg:&#123;msg&#125;&quot;)</span><br><span class="line">        conns.send(&quot;reply\n&quot;.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">socket_demo_tcp()</span><br></pre></td></tr></table></figure>
<h4 id="java-客户端"><a href="#java-客户端" class="headerlink" title="java 客户端"></a>java 客户端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class socket&#123;</span><br><span class="line"></span><br><span class="line">    private static final String HOST_ADDRESS = &quot;127.0.0.1&quot;;</span><br><span class="line">    private static final Integer PORT = 4001;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        </span><br><span class="line">            Socket socket = new Socket(HOST_ADDRESS, PORT);</span><br><span class="line">            //获取输出流，向服务器端发送信息</span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line">            //字节输出流</span><br><span class="line">            PrintWriter pw = new PrintWriter(os);</span><br><span class="line">            String data = &quot;hello&quot;;</span><br><span class="line">            //将输出流包装为打印流</span><br><span class="line">            pw.write(data + &quot;\n&quot;);</span><br><span class="line">            // 刷新缓冲区，发送数据</span><br><span class="line">            pw.flush();</span><br><span class="line">            //接收服务器的输入流</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            //读取服务器的输入流</span><br><span class="line">            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">            System.out.println(&quot;read start&quot;);</span><br><span class="line">            //读取服务器输入流并输出</span><br><span class="line">            String info = bufferedReader.readLine();</span><br><span class="line">            System.out.println(&quot;read finish&quot;);</span><br><span class="line">            if (info != null) &#123;</span><br><span class="line">                System.out.println(&quot;接收数据: &quot; + &quot;: 返回数据为：&quot; + info);</span><br><span class="line">            &#125; </span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;SendMsgThread: exceptionMsg: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="close与shutdown问题"><a href="#close与shutdown问题" class="headerlink" title="close与shutdown问题"></a>close与shutdown问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown():参数</span><br><span class="line">socket.SHUT_RD：关闭读操作，即recv</span><br><span class="line">socket.SHUT_WR：关闭写操作，即send</span><br><span class="line">socket.SHUT_RDWR：关闭读和写操作，即send recv</span><br><span class="line"># 如下内容发出消息后就关闭了读，因此无法获取到服务端返回给客户端的数据</span><br><span class="line">def shutdown():</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.send(b&quot;hello&quot;)</span><br><span class="line">    client.shutdown(socket.SHUT_RD)</span><br><span class="line">    data = client.recv(BUFFERSIZE)</span><br><span class="line">    print(f&quot;client data:&#123;data&#125;&quot;)</span><br><span class="line"></span><br><span class="line"># 如下客户端发送数据后关闭了写，因此还可以获取到服务端返回给客户端的数据</span><br><span class="line">def shutdown():</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.send(b&quot;hello&quot;)</span><br><span class="line">    client.shutdown(socket.SHUT_WR)</span><br><span class="line">    data = client.recv(BUFFERSIZE)</span><br><span class="line">    print(f&quot;client data:&#123;data&#125;&quot;)</span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure>
<p>建议先调用shutdown再调用close，避免数据丢失</p>
<h3 id="listen真的是最大连接数吗？"><a href="#listen真的是最大连接数吗？" class="headerlink" title="listen真的是最大连接数吗？"></a>listen真的是最大连接数吗？</h3><p>启用服务器以接受连接。如果指定backlog，则必须至少为0（如果低于0，则设置为0）；它指定系统在拒绝新连接之前将允许的未接受连接的数量。如果未指定，则选择默认的合理值。<br>简单来说，这里的nt表示socket的”排队个数“, 但目前存在疑问？不同系统，是否是同一台主机貌似会影响这个结果<br>一般情况下，一个进程只有一个主线程（也就是单线程），那么socket允许的最大连接数为: n + 1如果服务器是多线程，比如上面的代码例子是开了2个线程，那么socket允许的最大连接数就是: n + 2换句话说：排队的人数(就是那个n) + 正在就餐的人数（服务器正在处理的socket连接数) &#x3D; 允许接待的总人数（socket允许的最大连接数）</p>
<h4 id="服务端-5"><a href="#服务端-5" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import time</span><br><span class="line">HOST = &quot;&quot;</span><br><span class="line">PORT = 4001</span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def socket_demo_tcp():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    socket.socket(family=-1, type=-1, proto=-1, fileno=None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)</span><br><span class="line">    server_socket.bind((HOST, PORT))</span><br><span class="line">    server_socket.listen(1)</span><br><span class="line">    while True:</span><br><span class="line">        conns, address = server_socket.accept()</span><br><span class="line">        print(f&quot;conns:&#123;conns&#125;, address:&#123;address&#125;&quot;)</span><br><span class="line">        msg = conns.recv(BUFFERSIZE)</span><br><span class="line">        time.sleep(60)</span><br><span class="line">        print(f&quot;msg:&#123;msg&#125;&quot;)</span><br><span class="line">        conns.send(b&quot;reply&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="客户端-6"><a href="#客户端-6" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">HOST = &quot;192.168.XX.XXX&quot;</span><br><span class="line">HOST = &quot;127.0.0.1&quot;</span><br><span class="line">PORT = 4001 </span><br><span class="line">BUFFERSIZE = 1024</span><br><span class="line"></span><br><span class="line">def client_tcp():</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.send(b&quot;hello&quot;)</span><br><span class="line">    data = client.recv(BUFFERSIZE)</span><br><span class="line">    print(f&quot;client data:&#123;data&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>前提：listen为1<br>Windows–&gt;Windows： 当client进行第4个时会出现ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。<br>Linunx–&gt;Linux: 目前发现client是100个也不会出现Windows类似的连接拒绝<br>Linux–&gt; Windows、Windows–&gt; Linux:与Linux–&gt;Linux类似。不会出现连接拒绝的情况， 但如果开启线程的情况下，会出现连接失败情况<br>综上，listen在Windows上确实为排队连接的最大数量， 但在其他平台或者平台交互时表现却不是如此，望大佬指教</p>
<h3 id="socket-setsockopt-level-optname-value-optlen-int-详解"><a href="#socket-setsockopt-level-optname-value-optlen-int-详解" class="headerlink" title="socket.setsockopt(level, optname, value, optlen: int)详解"></a>socket.setsockopt(level, optname, value, optlen: int)详解</h3><h4 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h4><p>setsockopt()是对于socket的扩展，帮助设置socket的相关属性<br>level: 选项所在协议层<br>        SOL_SOCKET:通用套接字选项.<br>        IPPROTO_IP:IP选项.<br>        IPPROTO_TCP:TCP选项.<br>optname：具体的选项（socket中SO_*）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SO_DEBUG，打开或关闭调试信息。</span><br><span class="line">SO_REUSEADDR，打开或关闭地址复用功能。</span><br><span class="line">SO_DONTROUTE，打开或关闭路由查找功能。</span><br><span class="line">SO_BROADCAST，允许或禁止发送广播数据。</span><br><span class="line">SO_SNDBUF，设置发送缓冲区的大小。其上限为256 * (sizeof(struct sk_buff) + 256)，下限为2048字节。</span><br><span class="line">SO_RCVBUF，设置接收缓冲区的大小。上下限分别是：256 * (sizeof(struct sk_buff) + 256)和256字节。</span><br><span class="line">SO_KEEPALIVE，套接字保活。</span><br><span class="line">SO_OOBINLINE，紧急数据放入普通数据流。</span><br><span class="line">SO_NO_CHECK，打开或关闭校验和。</span><br><span class="line">SO_PRIORITY，设置在套接字发送的所有包的协议定义优先权。</span><br><span class="line">SO_LINGER，如果选择此选项, close或 shutdown将等到所有套接字里排队的消息成功发送或到达延迟时间后才会返回. 否则, 调用将立即返回。</span><br><span class="line">SO_PASSCRED，允许或禁止SCM_CREDENTIALS 控制消息的接收。</span><br><span class="line">SO_TIMESTAMP，打开或关闭数据报中的时间戳接收。</span><br><span class="line">SO_RCVLOWAT，设置接收数据前的缓冲区内的最小字节数。</span><br><span class="line">SO_RCVTIMEO，设置接收超时时间。</span><br><span class="line">SO_SNDTIMEO，设置发送超时时间。</span><br><span class="line">SO_BINDTODEVICE，将套接字绑定到一个特定的设备上。</span><br><span class="line">SO_ATTACH_FILTER和SO_DETACH_FILTER。</span><br></pre></td></tr></table></figure>
<p>value: 缓冲区大小<br>optlen: </p>
<p>返回说明：<br>    成功执行时，返回0。失败返回-1，errno被设为以下的某个值<br>    EBADF：sock不是有效的文件描述词<br>    EFAULT：optval指向的内存并非有效的进程空间<br>    EINVAL：在调用setsockopt()时，optlen无效<br>    ENOPROTOOPT：指定的协议层不能识别选项<br>    ENOTSOCK：sock描述的不是套接字</p>
<h4 id="3-设置缓冲区（发送缓冲区，接收缓冲区）"><a href="#3-设置缓冲区（发送缓冲区，接收缓冲区）" class="headerlink" title="3.设置缓冲区（发送缓冲区，接收缓冲区）"></a>3.设置缓冲区（发送缓冲区，接收缓冲区）</h4><p>当创建tcp和udp时默认会创建发送缓冲区和接收缓冲区<br>目前发现tcp服务端设置接收缓冲区大小会影响recv()中buffersize的作用，接收的数据由设置的接收缓冲区大小决定，其余则不会影响<br>tcp服务端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:</span><br><span class="line">    server.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 222)</span><br><span class="line">　#设置接收缓冲区大小为７</span><br><span class="line">    server.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 7)</span><br><span class="line">    server.bind((HOST, PORT))</span><br><span class="line">    server.listen(4)</span><br><span class="line">    while True:</span><br><span class="line">        conn, addr = server.accept()</span><br><span class="line">        print(f&quot;conn:&#123;conn&#125;, addr:&#123;addr&#125;&quot;)</span><br><span class="line">        data = conn.recv(BUFFERSIZE)</span><br><span class="line">        # 接收到的数据则为缓冲区大小数据</span><br><span class="line">        print(f&quot;data:&#123;data&#125;&quot;)</span><br><span class="line">        conn.send(data)</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:</span><br><span class="line">    client.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 4)</span><br><span class="line">    client.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 4)</span><br><span class="line">    # 设置发送的缓冲区大小</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.send(b&quot;helloasdadddddddddddd&quot;)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    data = client.recv(BUFFERSIZE)</span><br><span class="line">    print(f&quot;data:&#123;data&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="1-并发连接时端口冲突的问题，是由于在socket连接正常close后，会有一定的等待时间端口仍被占用，因此可以移除关闭后的等待时间-SO-REUSEADDR-可以重用端口"><a href="#1-并发连接时端口冲突的问题，是由于在socket连接正常close后，会有一定的等待时间端口仍被占用，因此可以移除关闭后的等待时间-SO-REUSEADDR-可以重用端口" class="headerlink" title="1.并发连接时端口冲突的问题，是由于在socket连接正常close后，会有一定的等待时间端口仍被占用，因此可以移除关闭后的等待时间 SO_REUSEADDR:可以重用端口"></a>1.并发连接时端口冲突的问题，是由于在socket连接正常close后，会有一定的等待时间端口仍被占用，因此可以移除关闭后的等待时间 SO_REUSEADDR:可以重用端口</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setsockopt(SOL_SOCKET ,SO_REUSEADDR,1);</span><br></pre></td></tr></table></figure>
<h5 id="2-设置收发时间，可能由于网络波动导致无法正常发送"><a href="#2-设置收发时间，可能由于网络波动导致无法正常发送" class="headerlink" title="2.设置收发时间，可能由于网络波动导致无法正常发送"></a>2.设置收发时间，可能由于网络波动导致无法正常发送</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setsockopt(SOL_SOCKET ,SO_SNDTIMEO,timeout);</span><br><span class="line">setsockopt(SOL_SOCKET ,SO_RCVTIMEO,timeout);</span><br><span class="line"></span><br><span class="line">import struct</span><br><span class="line">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:</span><br><span class="line">    # 需要使用struct将python数据转换为字节流</span><br><span class="line">    interval = struct.pack(&quot;ll&quot;, 10, 0)</span><br><span class="line">    print(interval)</span><br><span class="line">    client.setsockopt(socket.SOL_SOCKET, socket.SO_SNDTIMEO, interval)</span><br><span class="line">    client.connect((HOST, PORT))</span><br><span class="line">    client.send(b&quot;hello&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-取消socket默认缓冲区，提高性能，默认是从socket缓冲区读到系统缓冲区，然后由系统缓冲区发送"><a href="#3-取消socket默认缓冲区，提高性能，默认是从socket缓冲区读到系统缓冲区，然后由系统缓冲区发送" class="headerlink" title="3.取消socket默认缓冲区，提高性能，默认是从socket缓冲区读到系统缓冲区，然后由系统缓冲区发送"></a>3.取消socket默认缓冲区，提高性能，默认是从socket缓冲区读到系统缓冲区，然后由系统缓冲区发送</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 0)</span><br><span class="line">setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 0)</span><br></pre></td></tr></table></figure>
<h5 id="4-设置socket缓冲区，避免send-x2F-recv重复发送，send返回的是实际发送出去的数据-同步-或发送到socket缓冲区的数据-异步-，默认系统发送大小为8-8k，当发送数据量较大时则需要多次发送"><a href="#4-设置socket缓冲区，避免send-x2F-recv重复发送，send返回的是实际发送出去的数据-同步-或发送到socket缓冲区的数据-异步-，默认系统发送大小为8-8k，当发送数据量较大时则需要多次发送" class="headerlink" title="4.设置socket缓冲区，避免send&#x2F;recv重复发送，send返回的是实际发送出去的数据(同步)或发送到socket缓冲区的数据(异步)，默认系统发送大小为8.8k，当发送数据量较大时则需要多次发送"></a>4.设置socket缓冲区，避免send&#x2F;recv重复发送，send返回的是实际发送出去的数据(同步)或发送到socket缓冲区的数据(异步)，默认系统发送大小为8.8k，当发送数据量较大时则需要多次发送</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, buffersize)</span><br><span class="line">setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, buffersize)</span><br></pre></td></tr></table></figure>
<h4 id="5-设置非阻塞方式"><a href="#5-设置非阻塞方式" class="headerlink" title="5.设置非阻塞方式"></a>5.设置非阻塞方式</h4><h5 id="直接在创建时设置"><a href="#直接在创建时设置" class="headerlink" title="直接在创建时设置"></a>直接在创建时设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket.socket(socket.AF_INET, socket.SOCK_STREAM | socket.SOCK_NONBLOCK, proto=socket.IPPROTO_TCP)</span><br></pre></td></tr></table></figure>
<h5 id="创建完socket设置"><a href="#创建完socket设置" class="headerlink" title="创建完socket设置"></a>创建完socket设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.setblocking(False)</span><br></pre></td></tr></table></figure>
<h5 id="使用fcntl设置"><a href="#使用fcntl设置" class="headerlink" title="使用fcntl设置"></a>使用fcntl设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取当前文件描述符的状态</span><br><span class="line">flag = fcntl.fcntl(server, fcntl.F_GETFL, 0)</span><br><span class="line"># 设置为非阻塞</span><br><span class="line">fcntl.fcntl(server, fcntl.F_SETFL, flag | socket.SOCK_NONBLOCK)</span><br></pre></td></tr></table></figure>
<p>需要注意的是如果服务端在accept时设置非阻塞，由于当前没有客户端连接最好在accept时捕捉没有客户端的异常，防止流程中断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def tcp_non_block():</span><br><span class="line">    try:</span><br><span class="line">        with socket.socket(socket.AF_INET, socket.SOCK_STREAM | socket.SOCK_NONBLOCK, proto=socket.IPPROTO_TCP) as server:</span><br><span class="line">            server.bind((HOST, PORT))</span><br><span class="line">            # server.setblocking(False)</span><br><span class="line">            server.listen(3)</span><br><span class="line">            while True:</span><br><span class="line">                try:</span><br><span class="line">                    conn, addr = server.accept()</span><br><span class="line">                    print(f&quot;addr:&#123;addr&#125;&quot;)</span><br><span class="line">                    conn.setblocking(False)</span><br><span class="line">                    time.sleep(10)</span><br><span class="line">                    data = conn.recv(BUFFERSIZE)</span><br><span class="line">                    print(f&quot;data:&#123;data&#125;&quot;)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(f&quot;no client connect&quot;)</span><br><span class="line">                    time.sleep(4)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(f&quot;tcp_non_block error:&#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="socket缓冲区"><a href="#socket缓冲区" class="headerlink" title="socket缓冲区"></a>socket缓冲区</h3><p>一个 Socket 会带有两个缓冲区，一个用于发送、另一个用于接收。因为这是个先进先出的结构，所以有时也叫它们发送、接收队列<br>对于send来说，发送成功不代表已经发送到对应接收端，只是发送到发送缓冲区，由操作系统决定什么时候发送<br>由于涉及到缓冲区，因此缓冲区的状态及socket的状态会影响到send&#x2F;write或recv&#x2F;read的状态，详细可见socket缓冲区文章<br><img src="https://img2022.cnblogs.com/blog/2850640/202204/2850640-20220429103232761-19348255.webp" alt="image"></p>
<h3 id="socket相关流程图"><a href="#socket相关流程图" class="headerlink" title="socket相关流程图"></a>socket相关流程图</h3><h4 id="socket位置、常见socket通信方式，socket缓冲区"><a href="#socket位置、常见socket通信方式，socket缓冲区" class="headerlink" title="socket位置、常见socket通信方式，socket缓冲区"></a>socket位置、常见socket通信方式，socket缓冲区</h4><p><img src="https://img2022.cnblogs.com/blog/2850640/202204/2850640-20220429103125732-751616889.png" alt="image"></p>
<h4 id="select-IO多路复用-1"><a href="#select-IO多路复用-1" class="headerlink" title="select IO多路复用"></a>select IO多路复用</h4><p><img src="https://img2022.cnblogs.com/blog/2850640/202204/2850640-20220429103449922-1468225405.png" alt="image"></p>
<p>引用内容<br><a href="https://www.cnblogs.com/clschao/articles/9588313.html" title="sockopt">sockopt</a><br><a href="https://www.cnblogs.com/yuyutianxia/p/4908600.html" title="sockopt">sockopt_option</a><br><a href="https://www.cnblogs.com/traditional/p/11806454.html" title="socket缓冲区">socket缓冲区</a><br><a href="http://t.zoukankan.com/leijiangtao-p-11957234.html" title="shutdown与close区别">shutdown与close区别</a><br><a href="https://www.jb51.net/article/209798.htm" title="listen理解">listen理解</a><br>以上内容均来自python官网:<br><a href="https://docs.python.org/3/library/socket.html" title="socket文档">socket文档</a></p>
]]></content>
      <categories>
        <category>python重点理解</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python在管道中执行命令</title>
    <url>/2022/05/29/python%E5%9C%A8%E7%AE%A1%E9%81%93%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="python在管道中执行命令"><a href="#python在管道中执行命令" class="headerlink" title="python在管道中执行命令"></a>python在管道中执行命令</h2><p>在实际开发中，可能在执行命令过程中，需要在命令的管道中输入相应命令后继续执行，因此需要在执行命令后在命令的管道中输入相应指令</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>直接使用communicate向管道传入所需指令,注意如果是多个命令，需要在command中间添加\n，例如：ls\nifconfig</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def write_pipe1():</span><br><span class="line">    command = &quot;adb shell&quot;</span><br><span class="line">    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, \</span><br><span class="line">        stdin=subprocess.PIPE, bufsize=1, universal_newlines=True)</span><br><span class="line">    inner_command = &quot;ifconfig&quot;</span><br><span class="line">    output, error = p.communicate(inner_command)</span><br><span class="line">    print(f&quot;output:\n&#123;output&#125;\n error:&#123;error&#125;&quot;)</span><br><span class="line"></span><br><span class="line">write_pipe1()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>向管道中写入数据，使用communicate获取管道中的输出， 多个命令时与方法一类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def write_pipe2():</span><br><span class="line">    command = &quot;adb shell&quot;</span><br><span class="line">    p = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, \</span><br><span class="line">        stderr=subprocess.PIPE, bufsize=1, universal_newlines=True)</span><br><span class="line">    inner_command = &quot;ifconfig&quot;</span><br><span class="line">    p.stdin.write(inner_command)</span><br><span class="line">    # 刷新缓冲区</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    output, error = p.communicate()</span><br><span class="line">    print(f&quot;output:\n&#123;output&#125;\n error:&#123;error&#125;&quot;)</span><br><span class="line"></span><br><span class="line">write_pipe2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python常用函数</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python将命令输出写入文件或临时缓存</title>
    <url>/2022/05/29/python%E5%B0%86%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E6%88%96%E4%B8%B4%E6%97%B6%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="python将命令输出写入文件"><a href="#python将命令输出写入文件" class="headerlink" title="python将命令输出写入文件"></a>python将命令输出写入文件</h2><p>将文件写入到对应文件，方便后期处理或保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def write_file(file_path):</span><br><span class="line">    with open(file=file_path, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;) as out_file:</span><br><span class="line">        command = &quot;ifconfig&quot;</span><br><span class="line">        p = subprocess.Popen(command, shell=True, stdout=out_file, \</span><br><span class="line">            stdin=subprocess.PIPE, bufsize=1, universal_newlines=True)</span><br><span class="line">        print(p.pid)</span><br><span class="line"></span><br><span class="line">file_path = os.path.join(os.path.dirname(__file__), &quot;test.text&quot;)</span><br><span class="line">write_file(file_path)</span><br></pre></td></tr></table></figure>
<h2 id="python将命令输出写入临时文件或者缓存"><a href="#python将命令输出写入临时文件或者缓存" class="headerlink" title="python将命令输出写入临时文件或者缓存"></a>python将命令输出写入临时文件或者缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 临时文件,一般用于保存临时信息</span><br><span class="line">import tempfile</span><br><span class="line">def write_temp():</span><br><span class="line">    temp = tempfile.SpooledTemporaryFile(max_size=1024 * 10)</span><br><span class="line">    out_temp = temp.fileno()</span><br><span class="line">    command = &quot;ifconfig&quot;</span><br><span class="line">    p = subprocess.Popen(command, shell=True, stdout=out_temp, \</span><br><span class="line">        bufsize=1, universal_newlines=True)</span><br><span class="line">    print(p.pid)</span><br><span class="line">    print(out_temp.conjugate())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="tempfile不同临时文件的区别"><a href="#tempfile不同临时文件的区别" class="headerlink" title="tempfile不同临时文件的区别"></a>tempfile不同临时文件的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tempfile.TemporaryFile([mode=’w+b&#x27;[, bufsize=-1[, suffix=”[, prefix=’tmp&#x27;[, dir=None]]]]])</span><br></pre></td></tr></table></figure>
<p>该函数返回一个 类文件 对象(file-like)用于临时数据保存（实际上对应磁盘上的一个临时文件）。当文件对象被close或者被del的时候，临时文件将从磁盘上删除。mode、bufsize参数的单方与open()函数一样；suffix和prefix指定了临时文件名的后缀和前缀；dir用于设置临时文件默认的保存路径。返回的类文件对象有一个file属性，它指向真正操作的底层的file对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tempfile.NamedTemporaryFile([mode=’w+b&#x27;[, bufsize=-1[, suffix=”[, prefix=’tmp&#x27;[, dir=None[, delete=True]]]]]])</span><br></pre></td></tr></table></figure>
<p>tempfile.NamedTemporaryFile函数的行为与tempfile.TemporaryFile类似，只不过它多了一个delete参数，用于指定类文件对象close或者被del之后，是否也一同删除磁盘上的临时文件（当delete &#x3D; True的时候，行为与TemporaryFile一样）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tempfile.SpooledTemporaryFile([max_size=0[, mode=’w+b&#x27;[, bufsize=-1[, suffix=”[, prefix=’tmp&#x27;[, dir=None]]]]]])</span><br></pre></td></tr></table></figure>
<p>tempfile.SpooledTemporaryFile函数的行为与tempfile.TemporaryFile类似。不同的是向类文件对象写数据的时候，数据长度只有到达参数max_size指定大小时，或者调用类文件对象的fileno()方法，数据才会真正写入到磁盘的临时文件中。</p>
]]></content>
      <categories>
        <category>python常用函数</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
